{"tagline":"Rack middleware for rate-limiting incoming HTTP requests configured to be used with Redis.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"# Redis Throttle Middleware\r\n\r\nThis is a fork of the [Rack Throttle](http://github.com/datagraph/rack-throttle) middleware\r\nthat provides logic for rate-limiting incoming HTTP requests to Rack applications using\r\nRedis as storage system. You can use `Rack::RedisThrottle` with any Ruby web framework based\r\non Rack, including Ruby on Rails 3.0 and Sinatra. This gem was designed to experiment rate \r\nlimit with Rails 3.x and [Doorkeeper](https://github.com/applicake/doorkeeper/).\r\n\r\n## Features\r\n\r\n* Works only with Redis.\r\n* Automatically deploy by setting `ENV['REDIS_RATE_LIMIT_URL']`.\r\n* When the Redis connection is not available redis throttle skips the rate limit check (it does not blow up).\r\n* Automatically adds `X-RateLimit-Limit` and `X-RateLimit-Remaining` headers.\r\n* Set MockRedis while running your tests\r\n\r\n\r\n## Requirements\r\n\r\nDevices API is tested against MRI 1.9.3.\r\n\r\n\r\n## Installation\r\n\r\nUpdate your gem file and run `bundle`\r\n\r\n```ruby\r\ngem 'redis-throttle', git: 'git@github.com:andreareginato/redis-throttle.git'\r\n```\r\n\r\n## Rails Example\r\n\r\n```ruby\r\n# Limit the daily numebr of requests to 2500\r\nconfig.middleware.use Rack::RedisThrottle::Daily, max: 2500\r\n```\r\n\r\n## Sinatra example \r\n   \r\n```ruby\r\n#!/usr/bin/env ruby -rubygems\r\nrequire 'sinatra'\r\nrequire 'rack/throttle'\r\nuse Rack::Throttle::Daily, max: 2500\r\n```\r\n    \r\n## Rack app example \r\n \r\n```ruby\r\n#!/usr/bin/env rackup\r\nrequire 'rack/throttle'\r\nuse Rack::Throttle::Daily max: 2500\r\n\r\nrun lambda { |env| [200, {'Content-Type' => 'text/plain'}, \"Hello, world!\\n\"] }\r\n```\r\n\r\n## Customizations\r\n\r\nYou can fully customize the implementation details of any of these strategies\r\nby simply subclassing one of the default implementations. \r\n\r\nIn our example we want to reach those goals.\r\n\r\n* We want to use Doorkeper as authorization system (OAuth2)\r\n* The number of daily requests are based on the user id and not the IP\r\n  address (default in `Rack::RedisThrottle`)\r\n* The number of daily requests is dynamically set per user by the\r\n  `user#rate_limit` field.\r\n\r\nNow subclass `Rack::RedisThrottle::Daily`, create your own rules and use it in your Rails app\r\n\r\n```ruby\r\n# /lib/middlewares/daily_rate_limit\r\nrequire 'rack/redis_throttle'\r\n\r\nclass DailyRateLimit < Rack::RedisThrottle::Daily\r\n\r\n  def call(env)\r\n    @user_rate_limit = user_rate_limit(env)\r\n    super\r\n  end\r\n\r\n  def client_identifier(request)\r\n    @user_rate_limit.respond_to?(:_id) ? @user_rate_limit._id : 'user-unknown'\r\n  end\r\n\r\n  def max_per_window(request)\r\n    @user_rate_limit.respond_to?(:rate_limit) ? @user_rate_limit.rate_limit : 1000\r\n  end\r\n\r\n  # Rate limit only requests sending the access token\r\n  def need_protection?(request)\r\n    request.env.has_key?('HTTP_AUTHORIZATION')\r\n  end\r\n\r\n  private\r\n\r\n  def user_rate_limit(env)\r\n    request      = Rack::Request.new(env)\r\n    token        = request.env['HTTP_AUTHORIZATION'].split(' ')[-1]\r\n    access_token = Doorkeeper::AccessToken.where(token: token).first\r\n    access_token ? User.find(access_token.resource_owner_id) : nil\r\n  end\r\nend\r\n```\r\n\r\nNow you can use it in your Rails App.\r\n\r\n```ruby\r\n# config/application.rb\r\nmodule App\r\n  class Application < Rails::Application\r\n  \r\n    # Puts your rate limit middleware as high as you can in your middleware stack\r\n    config.middleware.insert_after Rack::Lock, 'DailyRateLimit'\r\n```\r\n\r\n## Rate limit headers\r\n\r\n`Rack::RedisThrottle` automatically sets two rate limits headers to let the \r\nclient know the max number of requests and the one availables.\r\n\r\n    HTTP/1.1 200 OK\r\n    X-RateLimit-Limit: 5000\r\n    X-RateLimit-Remaining: 4999\r\n\r\nWhen you exceed the API calls limit your request is forbidden.\r\n\r\n    HTTP/1.1 403 Forbidden\r\n    X-RateLimit-Limit: 5000\r\n    X-RateLimit-Remaining: 0\r\n\r\n\r\n# Testing your apps\r\n\r\nWhile testing your Rack app Mock the redis connection by requiring this file\r\n\r\n```ruby\r\n  # Rate limit fake redis connection\r\n  require 'rack/redis_throttle/testing/connection'\r\n```\r\n\r\n\r\n\r\n## HTTP client identification\r\n\r\nThe rate-limiting counters stored and maintained by `Rack::RedisThrottle` are\r\nkeyed to unique HTTP clients. By default, HTTP clients are uniquely identified\r\nby their IP address as returned by `Rack::Request#ip`. If you wish to instead\r\nuse a more granular, application-specific identifier such as a session key or\r\na user account name, you need only subclass a throttling strategy implementation\r\nand override the `#client_identifier` method.\r\n\r\n\r\n## HTTP Response Codes and Headers\r\n\r\nWhen a client exceeds their rate limit, `Rack::RedisThrottle` by default returns\r\na \"403 Forbidden\" response with an associated \"Rate Limit Exceeded\" message\r\nin the response body. If you need personalize it, for example with a\r\nJSON message.\r\n\r\n```ruby\r\ndef http_error(request, code, message = nil, headers = {})\r\n  [ code, { 'Content-Type' => 'application/json' }.merge(headers), [body(request).to_json] ]\r\nend\r\n\r\ndef body(request)\r\n  {\r\n    status: 403,\r\n    method: request.env['REQUEST_METHOD'],\r\n    request: \"#{request.env['rack.url_scheme']}://#{request.env['HTTP_HOST']}#{request.env['PATH_INFO']}\",\r\n    description: 'Rate limit exceeded',\r\n    daily_rate_limit: max_per_window(request)\r\n  }\r\nend\r\n```\r\n\r\n\r\n## Notes\r\n\r\n### Testing coverage\r\n\r\nOnly `Rack::RedisThrottle::Daily` has a test suite. We will cover all\r\nthe gem whenever I'll find more time and I'll see it being used widely.\r\n\r\n\r\n## Contributing\r\n\r\nFork the repo on github and send a pull requests with topic branches. Do not forget to\r\nprovide specs to your contribution.\r\n\r\n\r\n### Running specs\r\n\r\n* Fork and clone the repository.\r\n* Run `gem install bundler` to get the latest for the gemset.\r\n* Run `bundle install` for dependencies.\r\n* Run `bundle exec guard` and press enter to execute all specs.\r\n\r\n\r\n## Spec guidelines\r\n\r\nFollow [betterspecs.org](http://betterspecs.org) guidelines.\r\n\r\n\r\n## Coding guidelines\r\n\r\nFollow [github](https://github.com/styleguide/) guidelines.\r\n\r\n\r\n## Feedback\r\n\r\nUse the [issue tracker](https://github.com/andreareginato/redis-throttle/issues) for bugs.\r\n[Mail](mailto:andrea.reginato@gmail.com) or [Tweet](http://twitter.com/andreareginato)\r\nus for any idea that can improve the project.\r\n\r\n\r\n## Links\r\n\r\n* [GIT Repository](https://github.com/andreareginato/redis-throttle)\r\n* Initial inspiration form [Martinciu's dev blog](http://martinciu.com/2011/08/how-to-add-api-throttle-to-your-rails-app.html)\r\n\r\n\r\n## Authors\r\n\r\n[Andrea Reginato](http://twitter.com/andreareginato)\r\nThanks to [Lelylan](http://lelylan.com) for letting me share the code.\r\n\r\n\r\n## Contributors\r\n\r\nSpecial thanks to the following people for submitting patches.\r\n\r\n\r\n## Changelog\r\n\r\nSee [CHANGELOG](redis-throttle/blob/master/CHANGELOG.md)\r\n\r\n\r\n## Copyright\r\n\r\nRedis Throttle is free and unencumbered public domain software.\r\nSee [LICENCE](redis-throttle/blob/master/LICENSE.md)\r\n\r\n","name":"Redis-throttle"}